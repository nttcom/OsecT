module NO_IP;

# import zeek;

public type Packet = unit {
    arFType: uint8 &convert=RrFType($$);
    switch ( self.arFType ) {
        RrFType::TokenM         -> tokenM:   TokenM;
        RrFType::Persuasion     -> persuasion: Persuasion;
        RrFType::TestData       -> testData: TestData;
        RrFType::TestDataAck    -> testDataAck: TestDataAck;
        RrFType::Setup          -> setup: Setup;
        RrFType::SetupAck       -> setupAck: SetupAck;
        RrFType::MyStatus       -> myStatus: MyStatus;
        RrFType::Measure        -> measure: Measure;
        RrFType::MeasureAck     -> measureAck: MeasureAck;
        RrFType::Offset         -> offset: Offset;
        RrFType::Update         -> update: Update;
        RrFType::CyclicDataRWw  -> cyclicDataRWw: CyclicDataRWw;
        RrFType::CyclicDataRY   -> cyclicDataRY: CyclicDataRY;
        RrFType::CyclicDataRWr  -> cyclicDataRWr: CyclicDataRWr;
        RrFType::CyclicDataRX   -> cyclicDataRX: CyclicDataRX;
        RrFType::Transient1     -> transient1: Transient1;
        RrFType::TransientAck   -> transientAck: TransientAck;
        RrFType::Transient2     -> transient2: Transient2;
        RrFType::ParamCheck     -> paramCheck: ParamCheck;
        RrFType::Parameter      -> parameter: Parameter;
        RrFType::c_Timer        -> c_timer: c_Timer;
        RrFType::IpTransient    -> ipTransient: IpTransient;
        RrFType::Connect        -> connect: Connect;
        RrFType::ConnectAck     -> connectAck: ConnectAck;
        RrFType::Scan           -> scan: Scan;
        RrFType::Collect        -> collect: Collect;
        RrFType::Select         -> select: Select;
        RrFType::Launch         -> launch: Launch;
        RrFType::Token          -> token: Token;
        RrFType::Dummy          -> dummy: Dummy;
        RrFType::NTNTest        -> nTNTest: NTNTest;
        RrFType::CyclicDataW    -> cyclicDataW: CyclicDataW;
        RrFType::CyclicDataB    -> cyclicDataB: CyclicDataB;
        RrFType::CyclicDataOut1 -> cyclicDataOut1: CyclicDataOut1;
        RrFType::CyclicDataOut2 -> cyclicDataOut2: CyclicDataOut2;
        RrFType::CyclicDataIn1  -> cyclicDataIn1:   CyclicDataIn1;
        RrFType::CyclicDataIn2  -> cyclicDataIn2: CyclicDataIn2;
        *                       -> unk:   Unknown;
        };     
    on %done { print self;}
};

type RrFType = enum {
    TokenM = 0x15,
    Persuasion = 0x10,
    TestData = 0x11,
    TestDataAck = 0x12,
    Setup = 0x13,
    SetupAck = 0x14,
    MyStatus = 0x20,
    Measure = 0x40,
    MeasureAck = 0x41,
    Offset = 0x42,
    Update = 0x43,
    CyclicDataRWw = 0x82,
    CyclicDataRY = 0x83,
    CyclicDataRWr = 0x84,
    CyclicDataRX = 0x85,
    Transient1 = 0x22,
    TransientAck = 0x23,
    Transient2 = 0x25,
    ParamCheck = 0x28,
    Parameter = 0x29,
    c_Timer = 0x1c,
    IpTransient = 0x26,
    Connect = 0x00,
    ConnectAck = 0x01,
    Scan = 0x02,
    Collect = 0x03,
    Select = 0x04,
    Launch = 0x05,
    Token = 0x06,
    Dummy = 0x24,
    NTNTest = 0x2f,
    CyclicDataW = 0x80,
    CyclicDataB = 0x81,
    CyclicDataOut1 = 0x8c,
    CyclicDataOut2 = 0x8d,
    CyclicDataIn1 = 0x8e,
    CyclicDataIn2 = 0x8f,
};

# field 伝送制御フレーム
# -----------------------------------
type TokenM = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2: bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType:  bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Persuasion = unit {
    dataType:  bytes &size=1;
    persPriority:  bytes &size=3;
    nodeType: bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType:  bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type TestData = unit {
    dataType:  bytes &size=1;
    persPriority:  bytes &size=3;
    nodeType: bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType:  bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type TestDataAck = unit {
    dataType:  bytes &size=1;
    persPriority:  bytes &size=3;
    nodeType: bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType:  bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Setup = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2:  bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type SetupAck = unit {
    dataType:  bytes &size=1;
    reserved1:  bytes &size=4;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type MyStatus = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    syncFlag: bytes &size=1;
    nodeType:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};
# -----------------------------------

# field 同期フレーム
# -----------------------------------
type Measure = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2: bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type MeasureAck = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2: bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Offset = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2: bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Update = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2: bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};
# -----------------------------------

# field サイクリック伝送フレーム
# -----------------------------------
type CyclicDataRWw = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2: bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type CyclicDataRY = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2: bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type CyclicDataRWr = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2: bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type CyclicDataRX = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    reserved2: bytes &size=2;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};
# -----------------------------------

# field トランジェント伝送フレーム
# -----------------------------------
# ------------------------------------------
public function arrangement_transient1(msg: NO_IP::Transient1):
    tuple<
        command_7: bytes,
        sub_command_7: bytes,
        command_8: bytes,
        sub_command_8: bytes,
        ct: bytes
        >{
    
    local command_7: bytes;
    local subCommand_7: bytes;
    local command_8: bytes;
    local subCommand_8: bytes;
    local ct: bytes;

    if (msg?.common){
        print msg.common;
        ct = msg.common.ct;
    }
    if (msg?.ie_field){
        print msg.ie_field;
        command_7 = msg.ie_field.command;
        subCommand_7 = msg.ie_field.subCommand;
    }

    if (msg?.ie_field_motion){
        print msg.ie_field_motion;
        command_8 = msg.ie_field_motion.command;
        subCommand_8 = msg.ie_field_motion.subCommand;
    }

    return (
        command_7,
        subCommand_7,
        command_8,
        subCommand_8,
        ct,
    );
}

type Transient1 = unit {
    dataType:  uint8;
    nodeId:  uint16;
    connectionInfo: bytes &size=1;
    reserved4:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    traMsgHeader: bytes &size=16;
    switch ( self.dataType ) {
        0x05 -> common: Common;
        0x07 -> ie_field: Ie_field;
        0x08 -> ie_field_motion: Ie_field_motion;
    };
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type DataType = enum {
    Common = 0x05,
    Ie_field = 0x07,
    Ie_field_motion = 0x08,
};

type Common = unit {
                :   bytes &size=22;
    ct          :   bytes &size=1;
    except_data :   bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    # on %done { print self;}
};

type Ie_field = unit {
    command     :   bytes &size=1;
    subCommand  :   bytes &size=1;
    except_data :   bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    # on %done { print self; create_options(self);}
};

type Ie_field_motion = unit {
    command     :   bytes &size=1;
    subCommand  :   bytes &size=1;
    except_data :   bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    # on %done { print self;}
};
# ------------------------------------------

type TransientAck = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    connectionInfo: bytes &size=1;
    reserved4:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Transient2 = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    connectionInfo: bytes &size=1;
    reserved4:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
        :   bytes &size=22;
    ct:   bytes &size=1;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type ParamCheck = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    connectionInfo: bytes &size=1;
    reserved4:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Parameter = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    connectionInfo: bytes &size=1;
    reserved4:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type c_Timer = unit {
    dataType:  bytes &size=1;
    reserved1:  bytes &size=4;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type IpTransient = unit {
    dataType:  bytes &size=1;
    nodeId:  uint16;
    connectionInfo: bytes &size=1;
    reserved4:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    protocolVerType: bytes &size=1;
    reserved: bytes &size=1;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};
# -----------------------------------

# control 伝送制御フレーム
# -----------------------------------
type Connect = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type ConnectAck = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Scan = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Collect = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Select = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Launch = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Token = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type Dummy = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type NTNTest = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};
# -----------------------------------

# control サイクリック伝送フレーム
# -----------------------------------
type CyclicDataW = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type CyclicDataB = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type CyclicDataOut1 = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type CyclicDataOut2 = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type CyclicDataIn1 = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};

type CyclicDataIn2 = unit {
    c_priority:  bytes &size=1;
    scanNumber:  bytes &size=3;
    reserved1:  bytes &size=1;
    srcNodeNumber:  bytes &size=2;
    reserved2:  bytes &size=2;
    hec:  bytes &size=4;
    except_Header:  bytes &eod;

    # on %done { print self; zeek::confirm_protocol();}
    on %done { print self;}
};
# -----------------------------------

type Unknown = unit {
    data:          bytes &eod;

    # on %done { print self; }
};
